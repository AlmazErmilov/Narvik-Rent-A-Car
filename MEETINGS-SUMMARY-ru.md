## Анализ встречи от 11 июля 2024 года:

### Участники:

* Алексей: Frontend разработчик
* Алмаз Ермилов: Backend разработчик

### Тема:

Разработка приложения для бронирования автомобилей для компании Norvik Rent Car.

### Ключевые идеи:

1. **Разработка минималистичного MVP:** Создание максимально простой и функциональной системы для бронирования автомобилей, с фокусом на основные этапы: выбор даты/времени, автомобиля, ввод данных клиента, подтверждение заказа.

2. **REST API для фронтенда:** Создание API на основе Flask для взаимодействия фронтенда с базой данных. API будет включать:
* GET-запросы для получения списка доступных машин на выбранные даты, информации о локациях.
* POST-запрос для создания заказа с валидацией данных.
* Автоматическое присвоение уникального ID каждому заказу.
* Возможность добавления/редактирования информации о машинах, локациях через защищенный API (функционал админа).

3. **База данных:**
* Использование PostgreSQL для хранения информации о машинах, клиентах, заказах, локациях.
* Создание таблиц с необходимыми полями, обсуждение типов данных, отношений между таблицами.
* Автоматическое генерирование ID заказов и клиентов.
* Хранение ссылок на PDF-файлы договоров в базе данных.

4. **Отправка писем:**
* Автоматическая отправка писем клиенту и менеджеру при создании заказа.
* Использование сервиса почты Wix для отправки писем.
* Возможность отправки уведомлений менеджеру через push-уведомления (в будущем).

5. **Функционал админа:**
* Создание личного кабинета для менеджера (Виталия) с возможностью просмотра, редактирования заказов, добавления/редактирования информации о машинах и локациях.
* Добавление поля "комментарий" для менеджера в таблицу заказов.

6. **Интеграция с платежной системой:**
* Добавление функционала оплаты онлайн.
* Автоматическая проверка статуса оплаты и уведомление клиента и менеджера.
* Хранение ссылки на оплату и статуса оплаты в базе данных.

7. **Календарь бронирования:**
* Разработка календаря для отображения доступности машин на выбранные даты.
* Интеграция календаря с базой данных.

8. **Использование Docker:**
* Деплой приложения в Docker-контейнерах.
* Создание Dockerfile и docker-compose.yml для автоматизации сборки и запуска приложения.

9. **Документирование API:**
* Создание документации для API с помощью Swagger.
* Автоматическое генерирование документации из кода.

### Список дел:

#### Алмаз (backend):

#### Алмаз (backend):

- [x] Доработка базы *данных*:
- [x] Добавить поля "start_time", "end_time", "status" в таблицу "bookings".
- [x] Добавить поле "amount" в таблицу "payments".
- [x] Добавить поле "payment_link" в таблицу "payments".
- [x] Добавить поле "contract_sent" (boolean) в таблицу "bookings".
- [x] Добавить поле "driver_license_image" (string) в таблицу "customers".
- [x] Добавить поле "client_comment" (text) в таблицу "bookings".
- [x] Добавить поле "admin_comment" (text) в таблицу "bookings".
- [x] Переименовать поле "car_id" в "vehicle_id" в таблицах "bookings" и "cars".
- [x] Добавить таблицу "locations" с полями "city", "place", "additional_info".
- [x] Связать таблицы "bookings" и "locations" через поля "pickup_location_id" и "return_location_id".
- [ ] Реализация REST API:
- [ ] GET /api/v1/available_cars - получение списка доступных машин на выбранные даты с фильтрацией по количеству мест и типу трансмиссии.
- [ ] POST /api/v1/bookings - создание заказа с валидацией данных и автоматическим генерированием ID.
- [ ] GET /api/v1/locations - получение списка локаций.
- [ ] Реализация методов для добавления/редактирования информации о машинах, локациях через защищенный API.
- [ ] Разработка функционала отправки писем:
- [ ] Отправка писем клиенту и менеджеру при создании заказа.
- [ ] Использование сервиса почты Wix для отправки писем.
- [ ] Написание функций:
- [ ] Функция для генерирования уникального ID заказа.
- [ ] Функция для расчета стоимости заказа на основе количества дней и стоимости машины.
- [ ] Настройка Docker:
- [ ] Доработка Dockerfile и docker-compose.yml.
- [ ] Запуск приложения в Docker-контейнерах.
- [ ] Создание документации для API с помощью Swagger.
- [ ] Прикрутить авторизацию через JWT.


#### Алексей (frontend):

* Интеграция с REST API:
* Реализация запросов к API для получения списка доступных машин, информации о локациях, создания заказа.
* Разработка интерфейса для выбора даты/времени, автомобиля, ввода данных клиента.
* Разработка календаря бронирования.
* Создание функционала загрузки водительских прав.
* Доработка интерфейса с учетом новой информации о локациях.

#### Общие задачи:

* Обсуждение и выбор платежной системы.
* Реализация функционала онлайн-оплаты.
* Решение проблемы коллизий при бронировании.
* Разработка функционала админа.
* Разработка бизнес-модели для возможной монетизации приложения.
* Подготовка презентации проекта для Navitas.
* Обсуждение деталей интеграции с искусственным интеллектом (в будущем).

### REST API для Frontend:

**1. Получение списка доступных машин:**

* **URL:** `/api/v1/cars`
* **Method:** `GET`
* **Query parameters:**
* `pickup_date`: Дата и время начала аренды (ISO 8601 формат).
* `return_date`: Дата и время окончания аренды (ISO 8601 формат).
* `seats`: Минимальное количество мест.
* `pickup_location_id` (опционально): ID локации получения автомобиля.
* `return_location_id` (опционально): ID локации возврата автомобиля.
* `transmission` (опционально): Тип трансмиссии ("Automatic" или "Manual").
* **Ответ:**
* 200 OK: JSON массив с объектами, представляющими доступные автомобили. Каждый объект содержит поля `id`, `make`, `model`, `year`, `seats`, `transmission`, `fuel_type`, `category`, `daily_rate`.
* 400 Bad Request: Некорректные параметры запроса.

**Пример реализации:**

```python
@app.route('/api/v1/cars', methods=['GET'])
def get_available_cars():
# Получение параметров запроса
pickup_date = parse(request.args.get('pickup_date')).replace(tzinfo=tz.tzutc())
return_date = parse(request.args.get('return_date')).replace(tzinfo=tz.tzutc())
seats = int(request.args.get('seats'))
pickup_location_id = request.args.get('pickup_location_id')
return_location_id = request.args.get('return_location_id')
transmission = request.args.get('transmission')

# Валидация параметров

# Запрос к базе данных с фильтрацией
available_cars = Vehicle.query \
.filter(Vehicle.Status == 'Available', Vehicle.Seats >= seats) \
.filter( ... ) # Фильтрация по датам и локациям

# Формирование ответа
return jsonify([
{
'id': car.VehicleID,
'make': car.Make,
'model': car.Model,
'year': car.Year,
'seats': car.Seats,
'transmission': car.Transmission,
'fuel_type': car.FuelType,
'category': car.Category,
'daily_rate': float(car.DailyRate),
} for car in available_cars
])
```

**2. Создание бронирования:**

* **URL:** `/api/v1/bookings`
* **Method:** `POST`
* **Тело запроса:** JSON объект со структурой, соответствующей `OrderFormDataSchema`.
* **Ответ:**
* 201 Created: JSON объект с полями `id` (ID бронирования) и `total_cost` (общая стоимость).
* 400 Bad Request: Некорректные данные в запросе.
* 409 Conflict: Возникла коллизия при бронировании (машина уже забронирована).

**Пример реализации:**

```python
@app.route('/api/v1/bookings', methods=['POST'])
def create_booking():
schema = OrderFormDataSchema()
errors = schema.validate(request.json)
if errors:
return jsonify(errors), 400

data = request.json

# Проверка на коллизии

# Создание записи о клиенте

# Создание записи о бронировании
booking = Booking(
# ...
)
db.session.add(booking)
db.session.commit()

# Отправка email уведомлений

# Формирование PDF договора

return jsonify({
'id': booking.BookingID,
'total_cost': float(booking.TotalCost),
}), 201
```

**3. Получение списка локаций:**

* **URL:** `/api/v1/locations`
* **Method:** `GET`
* **Ответ:**
* 200 OK: JSON массив с объектами, представляющими локации. Каждый объект содержит поля `id`, `city`, `place`, `address`.
* 500 Internal Server Error: Ошибка при обработке запроса.

**Пример реализации:**

```python
@app.route('/api/v1/locations', methods=['GET'])
def get_locations():
locations = Location.query.all()
return jsonify([
{
'id': location.LocationID,
'city': location.City,
'place': location.Place,
'address': location.Address,
} for location in locations
])
```

### Краткая возможная реализация API

* **Язык программирования:** Python
* **Фреймворк:** Flask
* **ORM:** SQLAlchemy
* **Валидация данных:** Marshmallow
* **Документация API:** Swagger
* **Генерация UUID:** `uuid` модуль
* **Обработка дат:** `datetime`, `dateutil` модули
* **Отправка email:** `smtplib` или сторонние сервисы (SendGrid, Mailgun)
* **Генерация PDF:** `reportlab` или `fpdf` библиотеки
* **Платежная система:** Интеграция с API выбранной платежной системы.

### Инсайты и направления для дальнейшей работы:

* **Проблема коллизий:** Необходимо разработать механизм, предотвращающий бронирование одной машины двумя клиентами на overlapping даты. Возможные решения:
* Использовать транзакции при создании заказа.
* Блокировать запись о машине в базе данных на время создания заказа.
****
* **Автоматизация бизнес-процессов:** Автоматическое создание договоров, отправка писем/уведомлений, обработка онлайн-платежей.

* **Использование искусственного интеллекта:** Интеграция чат-бота для общения с клиентами, автоматического подбора автомобилей, анализа данных и составления отчетов.
